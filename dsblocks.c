#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <X11/Xlib.h>

#define CMDLENGTH			25
#define STTLENGTH			256
#define LOCKFILE			"/tmp/dsblocks.pid"

#define EMPTYCMDOUT(block)		(block->cmdoutcur[0] == '\0' || block->cmdoutcur[0] == '\n')
#define NOTATCMDOUTEND(block, i)	(i < CMDLENGTH && block->cmdoutcur[i] != '\0' && block->cmdoutcur[i] != '\n')

typedef struct {
        void (*funcu)(char *str, int *sigval);
	void (*funcc)(int button);
	const int interval;
	const int signal;
        char cmdoutcur[CMDLENGTH];
        char cmdoutprv[CMDLENGTH];
} Block;

static ssize_t getcmdout(char *const *arg, char *cmdout, size_t cmdoutlen);

#include "blocks.h"

static void buttonhandler(int signal, siginfo_t *si, void *ucontext);
static void setroot();
static void setupsignals();
static void sighandler(int signal, siginfo_t *si, void *ucontext);
static void statusloop();
static void termhandler(int signum);
static int updatestatus();
static void writepid();

static int statusContinue = 1;
static char statusstr[STTLENGTH];
static size_t delimlength;
static Display *dpy;

void
buttonhandler(int signal, siginfo_t *si, void *ucontext)
{
        signal = si->si_value.sival_int >> 8;
        for (Block *current = blocks; current->funcu; current++)
                if (current->signal == signal)
                        if (fork() == 0) {
                                close(ConnectionNumber(dpy));
                                setsid();
                                current->funcc(si->si_value.sival_int & 0xff);
                                exit(0);
                        }
}

ssize_t
getcmdout(char *const *arg, char *cmdout, size_t cmdoutlen)
{
        int fd[2];
        ssize_t rd;

        if (pipe(fd) == -1) {
                perror("getcmdout - pipe");
                exit(1);
        }
        switch (fork()) {
                case -1:
                        perror("getcmdout - fork");
                        exit(1);
                case 0:
                        close(ConnectionNumber(dpy));
                        close(fd[0]);
                        if (dup2(fd[1], STDOUT_FILENO) != STDOUT_FILENO) {
                                perror("getcmdout - child - dup2");
                                exit(1);
                        }
                        close(fd[1]);
                        execv(arg[0], arg);
                        perror("getcmdout - child - execv");
                        _exit(127);
                default:
                        close(fd[1]);
                        rd = read(fd[0], cmdout, cmdoutlen);
                        if (rd == -1) {
                                perror("getcmdout - read");
                                exit(1);
                        }
                        close(fd[0]);
        }
        return rd;
}

void
setroot()
{
	if (updatestatus()) /* only set root if block outputs have changed */
		return;
	XStoreName(dpy, DefaultRootWindow(dpy), statusstr);
        XFlush(dpy);
}

void
setupsignals()
{
        struct sigaction sa;

        sigemptyset(&sa.sa_mask);
        sa.sa_flags = SA_RESTART;
        /* to handle INT, HUP and TERM */
        sa.sa_handler = termhandler;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);
        /* to ignore unused realtime signals */
        sa.sa_handler = SIG_IGN;
        for (int i = SIGRTMIN; i <= SIGRTMAX; i++)
                sigaction(i, &sa, NULL);
        /* to handle signals generated by dwm on click events */
	sa.sa_flags = SA_RESTART | SA_SIGINFO;
	sa.sa_sigaction = buttonhandler;
	sigaction(SIGRTMIN, &sa, NULL);
        /* to handle update signals for individual blocks */
        sa.sa_sigaction = sighandler;
	for (Block *current = blocks; current->funcu; current++)
		if (current->signal > 0)
			sigaction(SIGRTMIN + current->signal, &sa, NULL);
        /* to prevent forked children from becoming zombies */
	sa.sa_flags = SA_NOCLDWAIT | SA_RESTART;
	sa.sa_handler = SIG_DFL;
        sigaction(SIGCHLD, &sa, NULL);
}

void
sighandler(int signal, siginfo_t *si, void *ucontext)
{
        signal -= SIGRTMIN;
	for (Block *current = blocks; current->funcu; current++)
		if (current->signal == signal)
			current->funcu(current->cmdoutcur, &(si->si_value.sival_int));
	setroot();
}

void
statusloop()
{
	int i;

	setupsignals();
        for (Block *current = blocks; current->funcu; current++)
                if (current->interval >= 0)
                        current->funcu(current->cmdoutcur, NULL);
        setroot();
        sleep(SLEEPINTERVAL);
        i = SLEEPINTERVAL;
	while (statusContinue) {
                for (Block *current = blocks; current->funcu; current++)
                        if (current->interval > 0 && i % current->interval == 0)
                                current->funcu(current->cmdoutcur, NULL);
		setroot();
		sleep(SLEEPINTERVAL);
		i += SLEEPINTERVAL;
	}
}

void
termhandler(int signum)
{
	statusContinue = 0;
}

/* returns whether block outputs have changed and updates statusstr if they have */
int
updatestatus()
{
        int i;
        char *str = statusstr;
        Block *current;

        for (current = blocks; current->funcu; current++) {
                if (EMPTYCMDOUT(current)) {
                        if (current->cmdoutprv[0] != current->cmdoutcur[0])
                                goto updatestrstrt;
                        continue;
                }
                i = 0;
                do {
                        if (current->cmdoutcur[i] == current->cmdoutprv[i]) {
                                i++;
                                continue;
                        } else {
                                str += i;
                                goto updatestrmddl;
                        }
                } while (NOTATCMDOUTEND(current, i));
                str += i;
                if (current->funcc && current->signal)
                        str++;
                str += delimlength;
        }
	return 1;
updatestrstrt:
        current->cmdoutprv[0] = current->cmdoutcur[0];
        for (current++; current->funcu; current++) {
                if (EMPTYCMDOUT(current)) {
                        current->cmdoutprv[0] = current->cmdoutcur[0];
                        continue;
                }
                i = 0;
updatestrmddl:
                do {
                        *(str++) = current->cmdoutcur[i];
                        current->cmdoutprv[i] = current->cmdoutcur[i];
                        i++;
                } while (NOTATCMDOUTEND(current, i));
                if (current->funcc && current->signal)
                        *(str++) = current->signal;
                for (i = 0; delim[i]; i++)
                        *(str++) = delim[i];
                *(str++) = '\n';
        }
        if (str != statusstr)
                *(str - delimlength) = '\0';
        return 0;
}

void
writepid()
{
        int fd;
        char buf[20];
        struct flock fl;
        ssize_t len;

        fd = open(LOCKFILE, O_RDWR|O_CREAT, 0644);
        if (fd == -1) {
                perror("writepid - fd");
                exit(1);
        }
        fl.l_type = F_WRLCK;
        fl.l_start = 0;
        fl.l_whence = SEEK_SET;
        fl.l_len = 0;
        if (fcntl(fd, F_SETLK, &fl) == -1) {
                if (errno == EACCES || errno == EAGAIN) {
                        fputs("Error: another instance of dsblocks is already running.\n", stderr);
                        exit(2);
                }
                perror("lockfile - fcntl");
                exit(1);
        }
        if (ftruncate(fd, 0) == -1) {
                perror("writepid - ftruncate");
                exit(1);
        }
        snprintf(buf, sizeof buf, "%ld", (long)getpid());
        len = strlen(buf);
        if (write(fd, buf, len) != len) {
                perror("writepid - write");
                exit(1);
        }
}

int
main(int argc, char *argv[])
{
        writepid();
        if (argc > 2)
                if (strcmp("-d", argv[1]) == 0)
                        delim = argv[2];
        delimlength = strlen(delim) + 1;
        if (!(dpy = XOpenDisplay(NULL))) {
                fputs("Error: could not open display.\n", stderr);
                return 1;
        }
	statusloop();
        unlink(LOCKFILE);
        XStoreName(dpy, DefaultRootWindow(dpy), "");
        XCloseDisplay(dpy);
        return 0;
}
